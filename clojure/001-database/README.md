# **ClojureとPostgreSQLにおけるロジック分割のプラグマティック・アーキテクトガイド**

### **Part I: 基本原則：分離のためのフレームワーク**

このパートでは、議論全体を支配する高レベルのアーキテクチャ原則を確立します。単純なルールを超え、問題について考えるための堅牢なメンタルモデルを構築します。

#### **1. 陳腐な表現を超えて：関心の分離（SoC）に関する現代的視点**

ソフトウェアアーキテクチャの議論において、「関心の分離（Separation of Concerns, SoC）」は頻繁に引用される原則ですが、その解釈はしばしば「ロジックはアプリケーションに、データはデータベースに」という単純な二元論に陥りがちです。しかし、現代的なシステム設計においては、このような硬直的な見方ではなく、システムを明確に定義された責務を持つ個別の部分に分割するという、より洗練されたアプローチが求められます¹。

この文脈において、データベースは単なる「ダムな（賢くない）」ストレージ層ではなく、それ自体が高度でステートフルなコンポーネントであり、独自の責務を持っています。したがって、本質的な問いは「分離するかどうか」ではなく、「どこに境界線を引くか」です。一般的なアプリケーションアーキテクチャは、プレゼンテーション層（UI、APIエンドポイント）、ビジネスロジック層（中核的な処理ロジック）、データアクセス層（DAL: データベース通信の管理）に分割されます¹。このレポートの目的は、PostgreSQLとClojureという技術スタックにおいて、このデータアクセス層（DAL）の適切な責務と範囲を定義することにあります。このアプローチは、SOLID原則、特に単一責任の原則（SRP: Single Responsibility Principle）と密接に関連しており、各層が「変更されるべき理由を一つだけ持つ」べきであるという考えに基づいています³。

この視点から「SQL対アプリケーションロジック」という従来の対立を再構成することが可能です。生産的な問いは、「データアクセス層の単一責任とは何か？」です。もしDALの責任が、「アプリケーションに対して、最も効率的で、一貫性があり、安全な形でデータを提供すること」であるならば、複雑なデータの整形、フィルタリング、集約といった操作は、明確にその責務の範囲内に含まれます。この解釈により、複雑なSQLは「ビジネスロジックの漏洩」ではなく、「DALがその主要な責務を果たしている状態」として捉え直すことができます。この考え方は、アプリケーションとデータベース間のロジック分割を判断するための強力なヒューリスティック（発見的手法）となります。つまり、問題はアプリケーションとデータベースの間の境界ではなく、異なる種類のロジック間の境界にあるのです⁴。DALの役割は、単にSELECT *を実行することではなく、データベース内のデータにのみ関わるすべての「データ中心のロジック」を処理することです。その結果、アプリケーションに残される「ビジネスロジック」は、このデータと他の関心事（外部API、ユーザーセッション、複数ステップのワークフローなど）を調整する役割を担うことになります。

#### **2. 境界線の設定：データロジックとビジネスロジックの区別**

ロジックを効果的に分割するためには、「データロジック」と「ビジネスロジック」を明確に区別することが不可欠です。この二つの概念は、実装場所を決定する際の重要な指針となります。

**データロジック（SQLに最適）**

データロジックとは、データベース内でデータセットに対して操作を行い、データの整合性を強制し、フィルタリング、集約、結合、そしてある形式から別の形式へのデータ変換を行うロジックを指します。その主要な関心事はデータそのものです⁵。

- **例1：** 地域ごとの総売上を計算する。
- **例2：** ある投稿に対する最新10件のコメントを取得する。
- **例3：** 新規レコードが複雑な複数テーブルにまたがる制約に違反しないことを保証する。

これらの操作は、データが格納されている場所、つまりデータベースで実行するのが最も効率的です。

**ビジネスロジック（Clojureに最適）**

ビジネスロジックとは、プロセスを調整し、外部システムと連携し、揮発性の高いビジネスルールに基づいて変更され、あるいは汎用プログラミング言語の表現力やツール群を必要とするロジックを指します⁴。

- **例1：** 注文がデータベースに挿入された後、Stripe APIを呼び出して決済を処理する。
- **例2：** 新規ユーザー登録時に歓迎メールを送信する。
- **例3：** ユーザーの購入履歴と頻繁に変更されるプロモーションルールに基づいて割引を適用する。

これらのロジックは、SQLの宣言的な性質や手続き型言語（PL/pgSQLなど）では表現が困難、あるいは不可能です⁶。Clojureのような強力なエコシステムを持つ言語が、その実装にはるかに適しています。

この技術的な分類に加えて、考慮すべき重要な非技術的側面が「ロジックの揮発性（変更頻度）」です。データベースのロジック（スキーマ、ストアドプロシージャなど）は、マイグレーションプロセスやDBA（データベース管理者）の関与が必要なため、アプリケーションコードに比べて変更の「摩擦」が大きいと認識されがちです⁴。アプリケーションコードのデプロイは、現代的なCI/CDパイプラインを通じて迅速かつ容易に行えることが多いのに対し、データベースの変更はより慎重な計画とリスク管理を伴います⁵。

したがって、あるロジックがSQLで効率的に実装可能であったとしても、ビジネスチームから毎週のように変更要求が来る可能性が高い場合、その開発・デプロイのオーバーヘッドを考慮すると、データベース層での実装は不適切かもしれません。この「揮発性の軸」は、純粋な技術的判断にプラグマティックなフィルターをかけるための重要な視点です。安定的でデータモデルの中核をなすロジックはデータベースの候補となり、実験的であったり、ビジネスの都合で頻繁に変わるロジックはアプリケーション層が適していると言えるでしょう。

#### **3. スケーラビリティの軸：水平的なアプリケーションスケーリング vs 垂直的なデータベーススケーリング**

アーキテクチャを設計する上で、アプリケーション層とデータベース層のスケーリング方法の根本的な違いを理解することは極めて重要です。

- **アプリケーションサーバー**は通常ステートレスであり、ロードバランサーの背後にインスタンスを追加することで**水平的に**スケールさせることができます。これは一般的に安価で容易なスケーリング方法です⁸。

- **データベースサーバー**はステートフルであり、通常はより強力なハードウェア（CPU、RAM、高速なディスク）を追加することで**垂直的に**スケールさせます。これは高価であり、物理的な限界が存在します⁹。

この違いは、ロジックの配置に関して中心的な緊張関係を生み出します。CPU負荷の高い処理をデータベースからアプリケーション層に移すことは、スケーラビリティの観点からは純粋な勝利に見えるかもしれません。しかし、それは「ネットワークを介して転送する必要のあるデータ量を劇的に増加させない」という条件付きです。

「アプリケーションは水平にスケールするからロジックをアプリ側に移すべきだ」という議論は、危険なほど単純化されすぎています。多くのWebアプリケーションにおける真のボトルネックは、データベースのCPUではなく、巨大でフィルタリングされていないデータセットをデータベースからアプリケーションに移動させる際のI/Oとネットワークレイテンシです。ロジックをアプリケーション側に移すことは、しばしばより多くの元データを取得し、それをアプリケーションのメモリ上でフィルタリングすることを意味します。これは、効率的なセットベースのデータベース操作を、非効率的な命令型のアプリケーション側操作に置き換え、ネットワークトラフィックを増大させる行為です。結果として、システム全体のスケーラビリティを損なうことさえあります。

この考察から導かれるのは、スケーラビリティに関するより洗練された原則です。CPUに負荷をかける**ビジネスロジック**はアプリケーションに移すべきですが、I/Oに負荷をかける**データのフィルタリングと集約**はデータベースに留めるべきです。最終的な目標は、ネットワークを介して転送するデータセットを、必要最小限の、最も精密な形にすることです。例えば、1000万行のテーブルから10行を抽出する「作業」を考えます。この作業をアプリケーションで行う場合、1000万行（あるいはその関連カラム）がネットワークを越える必要があり、これは膨大なI/Oコストを生みます。アプリケーションはその後、非効率的なループ処理でデータをフィルタリングします¹¹。一方、データベースでこの作業を行えば、フィルタリングの重い処理はデータベースが担い、わずか10行だけがネットワークを通過します。データベースはこの種のタスクに高度に最適化されています¹⁰。この原則を誤って適用すると、スケーラビリティを向上させるつもりが、かえって悪化させるという皮肉な結果を招きかねません。

### **Part II: データベースの最大活用：PostgreSQLにロジックを保持すべき場合**

このパートでは、ユーザーが直感的に感じている「SQLでやった方がいい」という考えを裏付け、データベースを積極的に活用するべき場面を具体的に論じます。

#### **4. データ重力の法則：ネットワークI/Oの最小化を最優先指令とする**

パフォーマンスに関する最も重要なヒューリスティックは、「データが置かれている場所で計算を実行し、データ転送を最小限に抑える」というものです。これを「データ重力の法則」と呼びます。

典型的な例は、平均や合計の計算です。100万行のデータをアプリケーションに転送して合計を計算するのは、データベースにSUM()関数を実行させて1行の結果を返させるのに比べて、桁違いに非効率です¹⁰。この原則は、結果セットのサイズを大幅に削減するあらゆる操作に適用されます。具体的には、フィルタリング（WHERE）、集約（GROUP BY）、そして選択的なカラム取得（SELECT *ではなくSELECT col1, col2）などが挙げられます¹⁴。

**ケーススタディ：N+1アンチパターン**

N+1クエリ問題は、データ重力の法則に違反する典型的なアンチパターンです。この問題は、まず1つのクエリでN個のアイテムを取得し、その後、各アイテムの関連データを取得するためにN個の追加クエリを実行することで発生します¹⁶。これにより、ネットワークのラウンドトリップが大量に発生し、アプリケーションのパフォーマンスは著しく低下します。

例えば、ブログの投稿一覧を表示し、各投稿のコメントも表示するケースを考えます。

1. SELECT * FROM posts; （1クエリ、N件の投稿を取得）
2. 各投稿についてループ処理： SELECT * FROM comments WHERE post_id = ?; （Nクエリ）

合計でN+1回のデータベースアクセスが発生します。

この問題の解決策は、必要なデータを最小限のクエリ（通常は1回か2回）でまとめて取得することです。

- **Eager Loading（積極的読み込み）:** JOINを使用して、投稿とコメントを1つのクエリで取得します。
  ```sql
  SELECT posts.*, comments.*
  FROM posts
  LEFT JOIN comments ON posts.id = comments.post_id;
  ```

- **Batching（一括処理）:** IN句を使用して、関連するすべてのコメントを1つの追加クエリで取得します。
  ```sql
  -- 1. 投稿を取得
  SELECT * FROM posts;
  -- 2. 取得した投稿IDのリストを使ってコメントを一括取得
  SELECT * FROM comments WHERE post_id IN (1, 2, 3, ...);
  ```

これらのアプローチは、ネットワークI/Oを劇的に削減し、データ重力の法則に従うことで、アプリケーションのパフォーマンスを根本的に改善します¹⁶。

#### **5. セットベース操作の力 vs 命令型処理**

SQLと一般的なアプリケーション言語の根本的な違いの一つは、その処理モデルにあります。SQLは宣言的で**セットベース**の言語であり、アプリケーション言語は命令的で**反復的**な処理を得意とします。

SQLは、データセット全体を一度に操作するように設計・最適化されています。クエリが発行されると、データベースのクエリオプティマイザが宣言全体を分析し、インデックスの使用や結合アルゴリズムの選択など、最も効率的な実行計画を立案します²⁰。このセットベースのアプローチにより、データベースは内部で高度な最適化を行うことができます。

対照的に、アプリケーションコードはレコードを一つずつループ処理する傾向があります。これはプログラマにとって自然な思考プロセスかもしれませんが、「行単位で考える」アプローチは、N+1問題のような非効率なパターンを生み出す温床となります¹⁰。SQLの「セットで考える」アプローチは、特に大規模なデータセットを扱う場合に、パフォーマンス上の圧倒的な優位性をもたらします。プログラマがセットを反復的に扱おうとする傾向は、パフォーマンスの疫病とも言える不要な負荷やN+1問題を引き起こす可能性があるため、可能な限りセットベースのアプローチを用いるべきです¹²。

#### **6. 複雑さの克服：高度なタスクのための保守可能なSQLの記述**

「長いクエリは保守が難しい」というユーザーの懸念は正当なものです。しかし、現代のSQLは、モジュール性と可読性を促進する強力な機能を提供しており、この問題を克服することができます。

##### **6.1. Common Table Expression (CTE)によるクエリのモジュール化**

Common Table Expression（CTE）は、WITH句を用いて、単一のクエリ内で名前付きの一時的な結果セットを作成する機能です²¹。CTEは、深くネストしたサブクエリが引き起こす可読性の問題を解決するための優れたツールです。複雑なクエリを、一連の論理的で順次的なステップに分解することができます²³。

例えば、以下のようなネストしたサブクエリを持つクエリがあったとします。

```sql
SELECT
  d.department_name,
  e.employee_name